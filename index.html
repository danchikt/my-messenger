const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const path = require('path');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const bcrypt = require('bcrypt');
const admin = require('firebase-admin');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';
const JWT_SECRET = 'your-secret-key-change-this';
const ADMIN_EMAIL = 'loling601@gmail.com';
const ADMIN_ID = 'admin';

// Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Firebase Admin
let firebaseInitialized = false;
try {
    const serviceAccount = require('./firebase-service-account.json');
    admin.initializeApp({
        credential: admin.credential.cert(serviceAccount)
    });
    firebaseInitialized = true;
    console.log('âœ… Firebase Admin Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½');
} catch (e) {
    console.log('âš ï¸ Firebase Ð½Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐ½ (Ð¿Ñ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼)');
}

// Ð‘Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…
const dbPath = path.join(__dirname, 'messenger.db');
const db = new sqlite3.Database(dbPath);

// Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹
db.serialize(() => {
    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
    db.run(`CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT UNIQUE,
        phone TEXT UNIQUE,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        bio TEXT DEFAULT '',
        avatar TEXT DEFAULT '',
        status TEXT DEFAULT 'offline',
        last_seen DATETIME,
        privacy_last_seen TEXT DEFAULT 'everyone',
        privacy_messages TEXT DEFAULT 'everyone',
        privacy_groups TEXT DEFAULT 'everyone',
        theme TEXT DEFAULT 'light',
        accent_color TEXT DEFAULT '#8774e1',
        notification_sound BOOLEAN DEFAULT 1,
        notification_vibrate BOOLEAN DEFAULT 1,
        notification_preview BOOLEAN DEFAULT 1,
        invisible_mode BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð´Ñ€ÑƒÐ·ÐµÐ¹/ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¾Ð²
    db.run(`CREATE TABLE IF NOT EXISTS friends (
        user_id TEXT,
        friend_id TEXT,
        status TEXT DEFAULT 'pending',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (user_id, friend_id),
        FOREIGN KEY (user_id) REFERENCES users(id),
        FOREIGN KEY (friend_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_id TEXT,
        to_id TEXT,
        text TEXT,
        file_data TEXT,
        file_name TEXT,
        file_type TEXT,
        edited BOOLEAN DEFAULT 0,
        reply_to INTEGER,
        forwarded_from TEXT,
        read BOOLEAN DEFAULT 0,
        read_at DATETIME,
        self_destruct BOOLEAN DEFAULT 0,
        self_destruct_time INTEGER,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (from_id) REFERENCES users(id),
        FOREIGN KEY (to_id) REFERENCES users(id),
        FOREIGN KEY (reply_to) REFERENCES messages(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ñ€ÐµÐ°ÐºÑ†Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS reactions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT,
        message_id INTEGER,
        reaction TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id),
        FOREIGN KEY (message_id) REFERENCES messages(id),
        UNIQUE(user_id, message_id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð·Ð°ÐºÑ€ÐµÐ¿Ð»Ñ‘Ð½Ð½Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS pinned_messages (
        chat_id TEXT,
        message_id INTEGER,
        pinned_by TEXT,
        pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (message_id) REFERENCES messages(id),
        FOREIGN KEY (pinned_by) REFERENCES users(id),
        PRIMARY KEY (chat_id, message_id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÐºÐ°Ð½Ð°Ð»Ð°
    db.run(`CREATE TABLE IF NOT EXISTS channel_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        content TEXT NOT NULL,
        author_id TEXT,
        author_name TEXT DEFAULT 'Clock Messenger',
        file_data TEXT,
        file_name TEXT,
        file_type TEXT,
        views INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (author_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¿Ð¾Ð´Ð¿Ð¸ÑÑ‡Ð¸ÐºÐ¾Ð² ÐºÐ°Ð½Ð°Ð»Ð°
    db.run(`CREATE TABLE IF NOT EXISTS channel_subscribers (
        user_id TEXT,
        subscribed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id),
        PRIMARY KEY (user_id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¾Ð² ÐºÐ°Ð½Ð°Ð»Ð°
    db.run(`CREATE TABLE IF NOT EXISTS channel_views (
        user_id TEXT,
        viewed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ² Ðº Ð¿Ð¾ÑÑ‚Ð°Ð¼ ÐºÐ°Ð½Ð°Ð»Ð°
    db.run(`CREATE TABLE IF NOT EXISTS channel_comments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER,
        user_id TEXT,
        text TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (message_id) REFERENCES channel_messages(id),
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÑÐ¾Ñ…Ñ€Ð°Ð½Ñ‘Ð½Ð½Ñ‹Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS saved_messages (
        user_id TEXT,
        message_id INTEGER,
        saved_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id),
        FOREIGN KEY (message_id) REFERENCES messages(id),
        PRIMARY KEY (user_id, message_id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð³Ñ€ÑƒÐ¿Ð¿
    db.run(`CREATE TABLE IF NOT EXISTS groups (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        created_by TEXT,
        welcome_message TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² Ð³Ñ€ÑƒÐ¿Ð¿
    db.run(`CREATE TABLE IF NOT EXISTS group_members (
        group_id TEXT,
        user_id TEXT,
        joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        role TEXT DEFAULT 'member',
        PRIMARY KEY (group_id, user_id),
        FOREIGN KEY (group_id) REFERENCES groups(id),
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð°Ð½Ð¸Ð¹ Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ð°Ñ…
    db.run(`CREATE TABLE IF NOT EXISTS group_polls (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id TEXT,
        created_by TEXT,
        question TEXT NOT NULL,
        options TEXT NOT NULL,
        multiple BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (group_id) REFERENCES groups(id),
        FOREIGN KEY (created_by) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¾Ñ‚Ð²ÐµÑ‚Ð¾Ð² Ð½Ð° Ð³Ð¾Ð»Ð¾ÑÐ¾Ð²Ð°Ð½Ð¸Ñ
    db.run(`CREATE TABLE IF NOT EXISTS poll_votes (
        poll_id INTEGER,
        user_id TEXT,
        option_index INTEGER,
        voted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (poll_id, user_id),
        FOREIGN KEY (poll_id) REFERENCES group_polls(id),
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð·Ð°ÐºÑ€ÐµÐ¿Ð»Ñ‘Ð½Ð½Ñ‹Ñ… ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð¾Ð²
    db.run(`CREATE TABLE IF NOT EXISTS pinned_contacts (
        user_id TEXT,
        contact_id TEXT,
        pinned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (user_id, contact_id),
        FOREIGN KEY (user_id) REFERENCES users(id),
        FOREIGN KEY (contact_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
    db.run(`CREATE TABLE IF NOT EXISTS blocked_users (
        user_id TEXT,
        blocked_id TEXT,
        blocked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (user_id, blocked_id),
        FOREIGN KEY (user_id) REFERENCES users(id),
        FOREIGN KEY (blocked_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° FCM Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²
    db.run(`CREATE TABLE IF NOT EXISTS fcm_tokens (
        user_id TEXT,
        token TEXT UNIQUE,
        device TEXT DEFAULT 'android',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id),
        PRIMARY KEY (user_id, token)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° ÑÑ‚Ð¸ÐºÐµÑ€Ð¾Ð²
    db.run(`CREATE TABLE IF NOT EXISTS stickers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        image_url TEXT NOT NULL,
        pack_name TEXT,
        animated BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS stories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT,
        image_url TEXT,
        text TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME DEFAULT (datetime('now', '+24 hours')),
        views INTEGER DEFAULT 0,
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¾Ð² Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¹
    db.run(`CREATE TABLE IF NOT EXISTS story_views (
        story_id INTEGER,
        user_id TEXT,
        viewed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        reaction TEXT,
        PRIMARY KEY (story_id, user_id),
        FOREIGN KEY (story_id) REFERENCES stories(id),
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);

    // Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° Ð±Ð¾Ñ‚Ð¾Ð²
    db.run(`CREATE TABLE IF NOT EXISTS bots (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        token TEXT UNIQUE NOT NULL,
        owner_id TEXT,
        webhook_url TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (owner_id) REFERENCES users(id)
    )`);

    // Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ Ð°Ð´Ð¼Ð¸Ð½Ð°
    bcrypt.hash('050506fyu', 10, (err, hash) => {
        if (err) throw err;
        
        db.run(`INSERT OR IGNORE INTO users (id, name, email, username, password_hash, bio) 
                VALUES (?, ?, ?, ?, ?, ?)`,
            [ADMIN_ID, 'ÐÐ´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€', ADMIN_EMAIL, 'admin', hash, 'Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÐµÐ»ÑŒ Clock Messenger'],
            function(err) {
                if (!err && this.changes) {
                    console.log('âœ… ÐÐ´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€ ÑÐ¾Ð·Ð´Ð°Ð½');
                    db.run(`INSERT OR IGNORE INTO channel_subscribers (user_id) VALUES (?)`, [ADMIN_ID]);
                }
            }
        );
    });
});

app.use(cors());
app.use(express.json({ limit: '50mb' }));

// Ð¥Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… WebSocket ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹
const clients = new Map();

// ========== Ð’Ð¡ÐŸÐžÐœÐžÐ“ÐÐ¢Ð•Ð›Ð¬ÐÐ«Ð• Ð¤Ð£ÐÐšÐ¦Ð˜Ð˜ ==========

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð´Ñ€ÑƒÐ·ÐµÐ¹
function getFriendsList(userId, callback) {
    db.all(`SELECT u.*, f.status as friend_status 
            FROM users u
            JOIN friends f ON (f.friend_id = u.id OR f.user_id = u.id)
            WHERE (f.user_id = ? OR f.friend_id = ?) 
            AND f.status = 'accepted' AND u.id != ?`,
        [userId, userId, userId], (err, friends) => {
            if (err) {
                console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð´Ñ€ÑƒÐ·ÐµÐ¹:', err);
                callback([]);
                return;
            }
            callback(friends || []);
        });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
function getBlockedUsers(userId, callback) {
    db.all(`SELECT blocked_id FROM blocked_users WHERE user_id = ?`, [userId], (err, blocked) => {
        if (err) {
            console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ…:', err);
            callback([]);
            return;
        }
        callback(blocked.map(b => b.blocked_id));
    });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð·Ð°ÐºÑ€ÐµÐ¿Ð»Ñ‘Ð½Ð½Ñ‹Ðµ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ñ‹
function getPinnedContacts(userId, callback) {
    db.all(`SELECT contact_id FROM pinned_contacts WHERE user_id = ?`, [userId], (err, pinned) => {
        if (err) {
            console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð·Ð°ÐºÑ€ÐµÐ¿Ð»Ñ‘Ð½Ð½Ñ‹Ñ…:', err);
            callback([]);
            return;
        }
        callback(pinned.map(p => p.contact_id));
    });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
function getUserGroups(userId, callback) {
    db.all(`SELECT g.* FROM groups g
            JOIN group_members gm ON gm.group_id = g.id
            WHERE gm.user_id = ?`, [userId], (err, groups) => {
        if (err) {
            console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð³Ñ€ÑƒÐ¿Ð¿:', err);
            callback([]);
            return;
        }
        callback(groups || []);
    });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹
function getGroupMembers(groupId, callback) {
    db.all(`SELECT user_id FROM group_members WHERE group_id = ?`, [groupId], (err, members) => {
        if (err) {
            console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹:', err);
            callback([]);
            return;
        }
        callback(members.map(m => m.user_id));
    });
}

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑ‡Ð¸ÐºÐ¾Ð² ÐºÐ°Ð½Ð°Ð»Ð°
function getChannelSubscribers(callback) {
    db.all(`SELECT user_id FROM channel_subscribers`, [], (err, subscribers) => {
        if (err) {
            callback([]);
            return;
        }
        callback(subscribers.map(s => s.user_id));
    });
}

// ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° PUSH-ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ
async function sendPushNotification(userId, title, body, data = {}) {
    if (!firebaseInitialized) return false;
    
    return new Promise((resolve) => {
        db.all(`SELECT token FROM fcm_tokens WHERE user_id = ?`, [userId], (err, tokens) => {
            if (err || !tokens || tokens.length === 0) {
                resolve(false);
                return;
            }
            
            const message = {
                notification: { 
                    title, 
                    body,
                    sound: 'default',
                    click_action: 'FLUTTER_NOTIFICATION_CLICK'
                },
                data: {
                    ...data,
                    click_action: 'FLUTTER_NOTIFICATION_CLICK'
                },
                tokens: tokens.map(t => t.token)
            };
            
            admin.messaging().sendEachForMulticast(message)
                .then(response => {
                    console.log(`âœ… Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¾ ${response.successCount} ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°Ð¼`);
                    resolve(true);
                })
                .catch(error => {
                    console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸:', error);
                    resolve(false);
                });
        });
    });
}

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ°Ð¼Ð¾ÑƒÐ½Ð¸Ñ‡Ñ‚Ð¾Ð¶Ð°ÑŽÑ‰Ð¸Ñ…ÑÑ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
setInterval(() => {
    db.run(`DELETE FROM messages WHERE self_destruct = 1 AND 
            datetime(timestamp, '+' || self_destruct_time || ' seconds') < datetime('now')`);
}, 60000); // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÐºÐ°Ð¶Ð´ÑƒÑŽ Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ

// ========== HTTP Ð­ÐÐ”ÐŸÐžÐ˜ÐÐ¢Ð« ==========

// Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ
app.post('/api/register', async (req, res) => {
    const { email, username, password, name, bio, phone } = req.body;
    
    if (!email || !username || !password) {
        return res.status(400).json({ error: 'Email, username Ð¸ password Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹' });
    }
    
    const userId = username.toLowerCase();
    
    bcrypt.hash(password, 10, (err, hash) => {
        if (err) return res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ' });
        
        db.run(`INSERT INTO users (id, name, email, username, password_hash, bio) 
                VALUES (?, ?, ?, ?, ?, ?)`,
            [userId, name || username, email, username, hash, bio || ''],
            function(err) {
                if (err) {
                    if (err.message.includes('UNIQUE')) {
                        return res.status(400).json({ error: 'Email Ð¸Ð»Ð¸ username ÑƒÐ¶Ðµ Ð·Ð°Ð½ÑÑ‚Ñ‹' });
                    }
                    return res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…' });
                }
                
                const token = jwt.sign({ userId, username }, JWT_SECRET);
                
                // ÐŸÐ¾Ð´Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÐ¼ Ð½Ð° ÐºÐ°Ð½Ð°Ð»
                db.run(`INSERT OR IGNORE INTO channel_subscribers (user_id) VALUES (?)`, [userId]);
                
                res.json({ 
                    success: true, 
                    token,
                    user: { id: userId, username, email, name: name || username, bio: bio || '' }
                });
            }
        );
    });
});

// Ð’Ñ…Ð¾Ð´
app.post('/api/login', (req, res) => {
    const { login, password } = req.body;
    
    if (!login || !password) {
        return res.status(400).json({ error: 'Ð›Ð¾Ð³Ð¸Ð½ Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹' });
    }
    
    db.get(`SELECT * FROM users WHERE email = ? OR phone = ? OR username = ? OR id = ?`,
        [login, login, login, login], (err, user) => {
            if (err || !user) {
                return res.status(401).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð»Ð¾Ð³Ð¸Ð½ Ð¸Ð»Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ' });
            }
            
            bcrypt.compare(password, user.password_hash, (err, isValid) => {
                if (!isValid) {
                    return res.status(401).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð»Ð¾Ð³Ð¸Ð½ Ð¸Ð»Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ' });
                }
                
                const token = jwt.sign({ userId: user.id, username: user.username }, JWT_SECRET);
                
                // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ last_seen
                db.run(`UPDATE users SET last_seen = CURRENT_TIMESTAMP WHERE id = ?`, [user.id]);
                
                res.json({
                    success: true,
                    token,
                    user: {
                        id: user.id,
                        username: user.username,
                        name: user.name,
                        email: user.email,
                        bio: user.bio,
                        avatar: user.avatar,
                        theme: user.theme,
                        accent_color: user.accent_color,
                        privacy_last_seen: user.privacy_last_seen,
                        privacy_messages: user.privacy_messages,
                        privacy_groups: user.privacy_groups,
                        notification_sound: user.notification_sound,
                        notification_vibrate: user.notification_vibrate,
                        notification_preview: user.notification_preview,
                        invisible_mode: user.invisible_mode
                    }
                });
            });
        }
    );
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑ‡Ð¸ÐºÐ¾Ð² ÐºÐ°Ð½Ð°Ð»Ð°
app.get('/api/channel/stats', (req, res) => {
    db.get(`SELECT COUNT(*) as subscribers FROM channel_subscribers`, (err, subResult) => {
        db.get(`SELECT COUNT(*) as views FROM channel_views`, (err, viewsResult) => {
            res.json({
                subscribers: subResult?.subscribers || 0,
                views: viewsResult?.views || 0
            });
        });
    });
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð²ÑÐµ ÑÑ‚Ð¸ÐºÐµÑ€Ñ‹
app.get('/api/stickers', (req, res) => {
    db.all(`SELECT * FROM stickers`, [], (err, stickers) => {
        res.json(stickers || []);
    });
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸
app.get('/api/stories', (req, res) => {
    db.all(`SELECT s.*, u.name as user_name, u.avatar as user_avatar,
            (SELECT COUNT(*) FROM story_views WHERE story_id = s.id) as views_count
            FROM stories s
            JOIN users u ON u.id = s.user_id
            WHERE expires_at > datetime('now')
            ORDER BY created_at DESC`, [], (err, stories) => {
        res.json(stories || []);
    });
});

// ========== WEBSOCKET ==========

wss.on('connection', (ws) => {
    console.log('âœ… ÐÐ¾Ð²Ñ‹Ð¹ WebSocket ÐºÐ»Ð¸ÐµÐ½Ñ‚');
    let currentUser = null;

    ws.on('message', async (message) => {
        try {
            const data = JSON.parse(message);
            console.log('ðŸ“¨ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾:', data.type);

            switch (data.type) {
                case 'auth':
                    const { token } = data;
                    
                    try {
                        const decoded = jwt.verify(token, JWT_SECRET);
                        currentUser = decoded;
                        
                        clients.set(currentUser.userId, ws);
                        
                        // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¸ last_seen (ÐµÑÐ»Ð¸ Ð½Ðµ Ð½ÐµÐ²Ð¸Ð´Ð¸Ð¼ÐºÐ°)
                        db.get(`SELECT invisible_mode FROM users WHERE id = ?`, [currentUser.userId], (err, user) => {
                            if (!err && user && !user.invisible_mode) {
                                db.run(`UPDATE users SET status = 'online', last_seen = CURRENT_TIMESTAMP WHERE id = ?`, [currentUser.userId]);
                            }
                        });
                        
                        // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
                        Promise.all([
                            new Promise(resolve => getFriendsList(currentUser.userId, resolve)),
                            new Promise(resolve => getBlockedUsers(currentUser.userId, resolve)),
                            new Promise(resolve => getPinnedContacts(currentUser.userId, resolve)),
                            new Promise(resolve => getUserGroups(currentUser.userId, resolve))
                        ]).then(([friends, blocked, pinned, groups]) => {
                            ws.send(JSON.stringify({
                                type: 'auth_success',
                                user: currentUser,
                                contacts: friends,
                                blocked: blocked,
                                pinnedContacts: pinned,
                                groups: groups
                            }));
                        });
                        
                        // ÐŸÐ¾Ð´Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÐ¼ Ð½Ð° ÐºÐ°Ð½Ð°Ð»
                        db.run(`INSERT OR IGNORE INTO channel_subscribers (user_id) VALUES (?)`, [currentUser.userId]);
                        
                        // ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ ÐºÐ°Ð½Ð°Ð»Ð°
                        db.all(`SELECT * FROM channel_messages ORDER BY created_at ASC`, [], (err, messages) => {
                            if (messages) {
                                messages.forEach(msg => {
                                    ws.send(JSON.stringify({
                                        type: 'channel_message',
                                        content: msg.content,
                                        author: 'Clock Messenger',
                                        timestamp: msg.created_at,
                                        fileData: msg.file_data,
                                        fileName: msg.file_name,
                                        fileType: msg.file_type,
                                        messageId: msg.id,
                                        views: msg.views
                                    }));
                                });
                            }
                        });
                        
                    } catch (e) {
                        ws.send(JSON.stringify({ type: 'auth_error', message: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚Ð¾ÐºÐµÐ½' }));
                    }
                    break;

                case 'register_fcm':
                    if (!currentUser) break;
                    
                    const { token: fcmToken, device } = data;
                    
                    db.run(`INSERT OR REPLACE INTO fcm_tokens (user_id, token, device) VALUES (?, ?, ?)`,
                        [currentUser.userId, fcmToken, device || 'android']);
                    break;

                case 'message':
                    if (!currentUser) {
                        ws.send(JSON.stringify({ type: 'error', message: 'ÐÐµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½' }));
                        break;
                    }
                    
                    const { to, text, replyTo, selfDestruct, selfDestructTime } = data;
                    
                    db.run(`INSERT INTO messages (from_id, to_id, text, reply_to, self_destruct, self_destruct_time) 
                            VALUES (?, ?, ?, ?, ?, ?)`,
                        [currentUser.userId, to, text, replyTo, selfDestruct || false, selfDestructTime || 0],
                        function(err) {
                            if (!err) {
                                const messageId = this.lastID;
                                
                                db.get(`SELECT * FROM messages WHERE id = ?`, [messageId], (err, message) => {
                                    if (message) {
                                        const targetSocket = clients.get(to);
                                        if (targetSocket && targetSocket.readyState === WebSocket.OPEN) {
                                            targetSocket.send(JSON.stringify({
                                                type: 'message',
                                                from: currentUser.userId,
                                                fromName: currentUser.username,
                                                text: text,
                                                timestamp: message.timestamp,
                                                messageId: messageId,
                                                replyTo: replyTo,
                                                selfDestruct: selfDestruct
                                            }));
                                        } else {
                                            // ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ PUSH-ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ
                                            sendPushNotification(
                                                to,
                                                currentUser.username,
                                                text.length > 50 ? text.substring(0, 50) + '...' : text,
                                                { 
                                                    chatId: currentUser.userId, 
                                                    messageId: messageId.toString(),
                                                    type: 'message'
                                                }
                                            );
                                        }
                                    }
                                });
                            }
                        }
                    );
                    break;

                case 'file_message':
                    if (!currentUser) break;
                    
                    const { to: fileTo, fileName, fileType, fileData } = data;
                    
                    db.run(`INSERT INTO messages (from_id, to_id, file_data, file_name, file_type) VALUES (?, ?, ?, ?, ?)`,
                        [currentUser.userId, fileTo, fileData, fileName, fileType],
                        function(err) {
                            if (!err) {
                                const messageId = this.lastID;
                                const targetSocket = clients.get(fileTo);
                                if (targetSocket && targetSocket.readyState === WebSocket.OPEN) {
                                    targetSocket.send(JSON.stringify({
                                        type: 'file_message',
                                        from: currentUser.userId,
                                        fromName: currentUser.username,
                                        fileName: fileName,
                                        fileType: fileType,
                                        fileData: fileData,
                                        timestamp: new Date().toISOString(),
                                        messageId: messageId
                                    }));
                                } else {
                                    sendPushNotification(
                                        fileTo,
                                        currentUser.username,
                                        'ðŸ“Ž ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ð»(Ð°) Ñ„Ð°Ð¹Ð»',
                                        { chatId: currentUser.userId, type: 'file' }
                                    );
                                }
                            }
                        }
                    );
                    break;

                case 'channel_message':
                    if (!currentUser) {
                        ws.send(JSON.stringify({ type: 'error', message: 'ÐÐµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½' }));
                        break;
                    }
                    
                    if (currentUser.userId !== ADMIN_ID) {
                        ws.send(JSON.stringify({ type: 'error', message: 'Ð¢Ð¾Ð»ÑŒÐºÐ¾ Ð°Ð´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð² ÐºÐ°Ð½Ð°Ð»' }));
                        break;
                    }
                    
                    const { content, fileData: channelFile, fileName: channelFileName, fileType: channelFileType } = data;
                    
                    db.run(`INSERT INTO channel_messages (content, author_id, author_name, file_data, file_name, file_type) 
                            VALUES (?, ?, ?, ?, ?, ?)`,
                        [content || '', currentUser.userId, 'Clock Messenger', channelFile, channelFileName, channelFileType],
                        function(err) {
                            if (err) {
                                console.error('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð² ÐºÐ°Ð½Ð°Ð»:', err);
                                return;
                            }
                            
                            const messageId = this.lastID;
                            
                            const message = {
                                type: 'channel_message',
                                content: content,
                                author: 'Clock Messenger',
                                timestamp: new Date().toISOString(),
                                messageId: messageId
                            };
                            
                            if (channelFile) {
                                message.fileData = channelFile;
                                message.fileName = channelFileName;
                                message.fileType = channelFileType;
                            }
                            
                            // Ð Ð°ÑÑÑ‹Ð»Ð°ÐµÐ¼ Ð²ÑÐµÐ¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÑ‡Ð¸ÐºÐ°Ð¼
                            getChannelSubscribers((subscribers) => {
                                subscribers.forEach(userId => {
                                    const subscriberWs = clients.get(userId);
                                    if (subscriberWs && subscriberWs.readyState === WebSocket.OPEN) {
                                        subscriberWs.send(JSON.stringify(message));
                                    } else {
                                        sendPushNotification(
                                            userId,
                                            'Clock Messenger',
                                            content || 'ðŸ“¢ ÐÐ¾Ð²Ñ‹Ð¹ Ð¿Ð¾ÑÑ‚ Ð² ÐºÐ°Ð½Ð°Ð»Ðµ',
                                            { type: 'channel', messageId: messageId.toString() }
                                        );
                                    }
                                });
                            });
                            
                            ws.send(JSON.stringify({
                                type: 'channel_message_sent',
                                messageId: messageId,
                                content: content
                            }));
                        }
                    );
                    break;

                case 'channel_comment':
                    if (!currentUser) break;
                    
                    const { messageId: channelMessageId, commentText } = data;
                    
                    db.run(`INSERT INTO channel_comments (message_id, user_id, text) VALUES (?, ?, ?)`,
                        [channelMessageId, currentUser.userId, commentText], function(err) {
                            if (!err) {
                                const commentId = this.lastID;
                                
                                // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÐµÐ¼ Ð°Ð´Ð¼Ð¸Ð½Ð°
                                if (currentUser.userId !== ADMIN_ID) {
                                    sendPushNotification(
                                        ADMIN_ID,
                                        currentUser.username,
                                        `ðŸ’¬ ÐšÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸Ð¹: ${commentText.substring(0, 30)}...`,
                                        { type: 'channel_comment', messageId: channelMessageId.toString() }
                                    );
                                }
                                
                                ws.send(JSON.stringify({
                                    type: 'comment_added',
                                    commentId: commentId,
                                    messageId: channelMessageId,
                                    text: commentText,
                                    userId: currentUser.userId,
                                    username: currentUser.username,
                                    timestamp: new Date().toISOString()
                                }));
                            }
                        });
                    break;

                case 'add_friend':
                    if (!currentUser) break;
                    
                    const { friendId } = data;
                    
                    db.get(`SELECT id, name, username FROM users WHERE id = ? OR username = ?`, 
                        [friendId, friendId], (err, friend) => {
                            if (!friend) {
                                ws.send(JSON.stringify({ type: 'error', message: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' }));
                                return;
                            }
                            
                            db.run(`INSERT INTO friends (user_id, friend_id, status) VALUES (?, ?, 'pending')`,
                                [currentUser.userId, friend.id], (err) => {
                                    if (err) {
                                        ws.send(JSON.stringify({ type: 'error', message: 'Ð—Ð°ÑÐ²ÐºÐ° ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚' }));
                                        return;
                                    }
                                    
                                    const friendWs = clients.get(friend.id);
                                    if (friendWs) {
                                        friendWs.send(JSON.stringify({
                                            type: 'friend_request',
                                            from: currentUser.userId,
                                            fromName: currentUser.username
                                        }));
                                    } else {
                                        sendPushNotification(
                                            friend.id,
                                            currentUser.username,
                                            'Ð¥Ð¾Ñ‡ÐµÑ‚ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð²Ð°Ñ Ð² Ð´Ñ€ÑƒÐ·ÑŒÑ',
                                            { type: 'friend_request', from: currentUser.userId }
                                        );
                                    }
                                    
                                    ws.send(JSON.stringify({ 
                                        type: 'friend_request_sent', 
                                        to: friend.id 
                                    }));
                                });
                        });
                    break;

                case 'accept_friend':
                    if (!currentUser) break;
                    
                    const { requesterId } = data;
                    
                    db.run(`UPDATE friends SET status = 'accepted' 
                            WHERE user_id = ? AND friend_id = ?`,
                        [requesterId, currentUser.userId], function(err) {
                            if (!err) {
                                getFriendsList(currentUser.userId, (contacts) => {
                                    ws.send(JSON.stringify({ 
                                        type: 'friends_list', 
                                        friends: contacts 
                                    }));
                                });
                                
                                const requesterWs = clients.get(requesterId);
                                if (requesterWs) {
                                    getFriendsList(requesterId, (contacts) => {
                                        requesterWs.send(JSON.stringify({ 
                                            type: 'friends_list', 
                                            friends: contacts 
                                        }));
                                    });
                                    
                                    requesterWs.send(JSON.stringify({
                                        type: 'friend_request_accepted',
                                        by: currentUser.userId,
                                        message: `ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ${currentUser.username} Ð¿Ñ€Ð¸Ð½ÑÐ» Ð²Ð°ÑˆÑƒ Ð·Ð°ÑÐ²ÐºÑƒ`
                                    }));
                                } else {
                                    sendPushNotification(
                                        requesterId,
                                        currentUser.username,
                                        'ÐŸÑ€Ð¸Ð½ÑÐ»(Ð°) Ð²Ð°ÑˆÑƒ Ð·Ð°ÑÐ²ÐºÑƒ Ð² Ð´Ñ€ÑƒÐ·ÑŒÑ',
                                        { type: 'friend_accepted' }
                                    );
                                }
                            }
                        });
                    break;

                case 'decline_friend':
                    if (!currentUser) break;
                    
                    const { requesterId: declineId } = data;
                    
                    db.run(`DELETE FROM friends WHERE user_id = ? AND friend_id = ?`,
                        [declineId, currentUser.userId]);
                    break;

                case 'delete_friend':
                    if (!currentUser) break;
                    
                    const { friendId: deleteId } = data;
                    
                    db.run(`DELETE FROM friends WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)`,
                        [currentUser.userId, deleteId, deleteId, currentUser.userId]);
                    
                    getFriendsList(currentUser.userId, (contacts) => {
                        ws.send(JSON.stringify({ type: 'friends_list', friends: contacts }));
                    });
                    
                    const deletedFriendWs = clients.get(deleteId);
                    if (deletedFriendWs) {
                        getFriendsList(deleteId, (contacts) => {
                            deletedFriendWs.send(JSON.stringify({ type: 'friends_list', friends: contacts }));
                        });
                    }
                    break;

                case 'block_user':
                    if (!currentUser) break;
                    
                    const { blockedId } = data;
                    
                    db.run(`INSERT OR IGNORE INTO blocked_users (user_id, blocked_id) VALUES (?, ?)`,
                        [currentUser.userId, blockedId]);
                    
                    db.run(`DELETE FROM friends WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)`,
                        [currentUser.userId, blockedId, blockedId, currentUser.userId]);
                    
                    getBlockedUsers(currentUser.userId, (blocked) => {
                        ws.send(JSON.stringify({ type: 'blocked_list', blocked: blocked }));
                    });
                    break;

                case 'unblock_user':
                    if (!currentUser) break;
                    
                    const { unblockedId } = data;
                    
                    db.run(`DELETE FROM blocked_users WHERE user_id = ? AND blocked_id = ?`,
                        [currentUser.userId, unblockedId]);
                    
                    getBlockedUsers(currentUser.userId, (blocked) => {
                        ws.send(JSON.stringify({ type: 'blocked_list', blocked: blocked }));
                    });
                    break;

                case 'pin_contact':
                    if (!currentUser) break;
                    
                    const { contactId } = data;
                    
                    db.run(`INSERT OR IGNORE INTO pinned_contacts (user_id, contact_id) VALUES (?, ?)`,
                        [currentUser.userId, contactId]);
                    
                    getPinnedContacts(currentUser.userId, (pinned) => {
                        ws.send(JSON.stringify({ type: 'pinned_contacts', pinned: pinned }));
                    });
                    break;

                case 'unpin_contact':
                    if (!currentUser) break;
                    
                    const { unpinId } = data;
                    
                    db.run(`DELETE FROM pinned_contacts WHERE user_id = ? AND contact_id = ?`,
                        [currentUser.userId, unpinId]);
                    
                    getPinnedContacts(currentUser.userId, (pinned) => {
                        ws.send(JSON.stringify({ type: 'pinned_contacts', pinned: pinned }));
                    });
                    break;

                case 'clear_chat':
                    if (!currentUser) break;
                    
                    const { chatId: clearChatId } = data;
                    
                    db.run(`DELETE FROM messages WHERE (from_id = ? AND to_id = ?) OR (from_id = ? AND to_id = ?)`,
                        [currentUser.userId, clearChatId, clearChatId, currentUser.userId], function(err) {
                            if (!err) {
                                const targetSocket = clients.get(clearChatId);
                                if (targetSocket && targetSocket.readyState === WebSocket.OPEN) {
                                    targetSocket.send(JSON.stringify({
                                        type: 'chat_cleared',
                                        chatId: clearChatId,
                                        by: currentUser.userId
                                    }));
                                }
                                
                                ws.send(JSON.stringify({
                                    type: 'chat_cleared',
                                    chatId: clearChatId,
                                    by: currentUser.userId
                                }));
                            }
                        });
                    break;

                case 'clear_channel':
                    if (!currentUser || currentUser.userId !== ADMIN_ID) break;
                    
                    db.run(`DELETE FROM channel_messages`, function(err) {
                        if (!err) {
                            clients.forEach((client, userId) => {
                                if (client && client.readyState === WebSocket.OPEN) {
                                    client.send(JSON.stringify({
                                        type: 'channel_cleared'
                                    }));
                                }
                            });
                        }
                    });
                    break;

                case 'update_profile':
                    if (!currentUser) break;
                    
                    const { name, bio, avatar, theme, accent_color, privacy_last_seen, privacy_messages, privacy_groups, notification_sound, notification_vibrate, notification_preview, invisible_mode } = data;
                    
                    db.run(`UPDATE users SET name = ?, bio = ?, avatar = ?, theme = ?, accent_color = ?, 
                            privacy_last_seen = ?, privacy_messages = ?, privacy_groups = ?,
                            notification_sound = ?, notification_vibrate = ?, notification_preview = ?,
                            invisible_mode = ?
                            WHERE id = ?`,
                        [name, bio, avatar, theme, accent_color, privacy_last_seen, privacy_messages, privacy_groups,
                         notification_sound, notification_vibrate, notification_preview, invisible_mode, currentUser.userId]);
                    break;

                case 'get_channel_stats':
                    db.get(`SELECT COUNT(*) as subscribers FROM channel_subscribers`, (err, subResult) => {
                        db.get(`SELECT COUNT(*) as views FROM channel_views`, (err, viewsResult) => {
                            ws.send(JSON.stringify({
                                type: 'channel_stats',
                                subscribers: subResult?.subscribers || 0,
                                views: viewsResult?.views || 0
                            }));
                        });
                    });
                    break;

                case 'channel_view':
                    if (currentUser) {
                        db.run(`INSERT OR IGNORE INTO channel_views (user_id) VALUES (?)`, [currentUser.userId]);
                        db.run(`UPDATE channel_messages SET views = views + 1 WHERE id IN (SELECT id FROM channel_messages ORDER BY id DESC LIMIT 10)`);
                    }
                    break;

                case 'create_group':
                    if (!currentUser) break;
                    
                    const { group } = data;
                    
                    db.serialize(() => {
                        db.run(`INSERT INTO groups (id, name, description, created_by, welcome_message) VALUES (?, ?, ?, ?, ?)`,
                            [group.id, group.name, group.description, currentUser.userId, group.welcomeMessage || '']);
                        
                        db.run(`INSERT INTO group_members (group_id, user_id, role) VALUES (?, ?, 'creator')`,
                            [group.id, currentUser.userId]);
                        
                        ws.send(JSON.stringify({
                            type: 'group_created',
                            group: { ...group, members: [currentUser.userId] }
                        }));
                    });
                    break;

                case 'add_to_group':
                    if (!currentUser) break;
                    
                    const { groupId, members } = data;
                    
                    members.forEach(memberId => {
                        db.run(`INSERT OR IGNORE INTO group_members (group_id, user_id) VALUES (?, ?)`,
                            [groupId, memberId], function(err) {
                                if (!err) {
                                    const memberWs = clients.get(memberId);
                                    if (memberWs) {
                                        db.get(`SELECT * FROM groups WHERE id = ?`, [groupId], (err, group) => {
                                            if (group) {
                                                memberWs.send(JSON.stringify({
                                                    type: 'group_created',
                                                    group: group
                                                }));
                                            }
                                        });
                                    } else {
                                        db.get(`SELECT name FROM groups WHERE id = ?`, [groupId], (err, group) => {
                                            if (group) {
                                                sendPushNotification(
                                                    memberId,
                                                    currentUser.username,
                                                    `Ð”Ð¾Ð±Ð°Ð²Ð¸Ð»(Ð°) Ð²Ð°Ñ Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ñƒ "${group.name}"`,
                                                    { type: 'group_added', groupId: groupId }
                                                );
                                            }
                                        });
                                    }
                                }
                            });
                    });
                    
                    getGroupMembers(groupId, (membersList) => {
                        ws.send(JSON.stringify({
                            type: 'group_members_updated',
                            groupId: groupId,
                            count: membersList.length
                        }));
                    });
                    break;

                case 'kick_from_group':
                    if (!currentUser) break;
                    
                    const { groupId: kickGroupId, memberId } = data;
                    
                    db.run(`DELETE FROM group_members WHERE group_id = ? AND user_id = ?`,
                        [kickGroupId, memberId]);
                    
                    const kickedWs = clients.get(memberId);
                    if (kickedWs) {
                        kickedWs.send(JSON.stringify({
                            type: 'member_kicked',
                            groupId: kickGroupId,
                            memberId: memberId
                        }));
                    } else {
                        sendPushNotification(
                            memberId,
                            currentUser.username,
                            'Ð’Ð°Ñ Ð¸ÑÐºÐ»ÑŽÑ‡Ð¸Ð»Ð¸ Ð¸Ð· Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹',
                            { type: 'group_kicked', groupId: kickGroupId }
                        );
                    }
                    
                    getGroupMembers(kickGroupId, (membersList) => {
                        ws.send(JSON.stringify({
                            type: 'group_members_updated',
                            groupId: kickGroupId,
                            count: membersList.length
                        }));
                    });
                    break;

                case 'delete_group':
                    if (!currentUser) break;
                    
                    const { groupId: deleteGroupId } = data;
                    
                    db.run(`DELETE FROM group_members WHERE group_id = ?`, [deleteGroupId]);
                    db.run(`DELETE FROM groups WHERE id = ?`, [deleteGroupId]);
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'group_deleted',
                                groupId: deleteGroupId
                            }));
                        } else {
                            sendPushNotification(
                                userId,
                                'Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð°',
                                'Ð“Ñ€ÑƒÐ¿Ð¿Ð° Ð±Ñ‹Ð»Ð° ÑƒÐ´Ð°Ð»ÐµÐ½Ð°',
                                { type: 'group_deleted', groupId: deleteGroupId }
                            );
                        }
                    });
                    break;

                case 'leave_group':
                    if (!currentUser) break;
                    
                    const { groupId: leaveGroupId } = data;
                    
                    db.run(`DELETE FROM group_members WHERE group_id = ? AND user_id = ?`,
                        [leaveGroupId, currentUser.userId]);
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN && userId !== currentUser.userId) {
                            client.send(JSON.stringify({
                                type: 'member_kicked',
                                groupId: leaveGroupId,
                                memberId: currentUser.userId
                            }));
                        }
                    });
                    break;

                case 'create_poll':
                    if (!currentUser) break;
                    
                    const { pollGroupId, question, options, multiple } = data;
                    
                    db.run(`INSERT INTO group_polls (group_id, created_by, question, options, multiple) 
                            VALUES (?, ?, ?, ?, ?)`,
                        [pollGroupId, currentUser.userId, question, JSON.stringify(options), multiple || false],
                        function(err) {
                            if (!err) {
                                const pollId = this.lastID;
                                
                                getGroupMembers(pollGroupId, (members) => {
                                    members.forEach(memberId => {
                                        const memberWs = clients.get(memberId);
                                        const pollData = {
                                            type: 'new_poll',
                                            pollId: pollId,
                                            groupId: pollGroupId,
                                            question: question,
                                            options: options,
                                            multiple: multiple,
                                            createdBy: currentUser.userId
                                        };
                                        
                                        if (memberWs && memberWs.readyState === WebSocket.OPEN) {
                                            memberWs.send(JSON.stringify(pollData));
                                        } else if (memberId !== currentUser.userId) {
                                            sendPushNotification(
                                                memberId,
                                                currentUser.username,
                                                `ÐÐ¾Ð²Ñ‹Ð¹ Ð¾Ð¿Ñ€Ð¾Ñ Ð² Ð³Ñ€ÑƒÐ¿Ð¿Ðµ: ${question}`,
                                                { type: 'new_poll', pollId: pollId.toString() }
                                            );
                                        }
                                    });
                                });
                            }
                        });
                    break;

                case 'vote_poll':
                    if (!currentUser) break;
                    
                    const { pollId, optionIndex } = data;
                    
                    db.run(`INSERT OR REPLACE INTO poll_votes (poll_id, user_id, option_index) VALUES (?, ?, ?)`,
                        [pollId, currentUser.userId, optionIndex]);
                    break;

                case 'reaction':
                    if (!currentUser) break;
                    
                    const { chatId: reactionChatId, messageId: reactionMessageId, reaction: reactionEmoji, remove } = data;
                    
                    if (remove) {
                        db.run(`DELETE FROM reactions WHERE user_id = ? AND message_id = ?`,
                            [currentUser.userId, reactionMessageId]);
                    } else {
                        db.run(`INSERT OR REPLACE INTO reactions (user_id, message_id, reaction) VALUES (?, ?, ?)`,
                            [currentUser.userId, reactionMessageId, reactionEmoji]);
                    }
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'reaction',
                                chatId: reactionChatId,
                                messageId: reactionMessageId,
                                reaction: reactionEmoji,
                                userId: currentUser.userId,
                                remove: remove
                            }));
                        }
                    });
                    break;

                case 'pin_message':
                    if (!currentUser) break;
                    
                    const { chatId: pinChatId, message: pinMessage } = data;
                    
                    db.run(`INSERT OR REPLACE INTO pinned_messages (chat_id, message_id, pinned_by) VALUES (?, ?, ?)`,
                        [pinChatId, pinMessage.id, currentUser.userId]);
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'pin_message',
                                chatId: pinChatId,
                                message: pinMessage
                            }));
                        }
                    });
                    break;

                case 'unpin_message':
                    if (!currentUser) break;
                    
                    const { chatId: unpinChatId } = data;
                    
                    db.run(`DELETE FROM pinned_messages WHERE chat_id = ?`, [unpinChatId]);
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'unpin_message',
                                chatId: unpinChatId
                            }));
                        }
                    });
                    break;

                case 'edit_message':
                    if (!currentUser) break;
                    
                    const { chatId: editChatId, messageId: editMessageId, text: newText } = data;
                    
                    db.run(`UPDATE messages SET text = ?, edited = 1 WHERE id = ? AND from_id = ?`,
                        [newText, editMessageId, currentUser.userId]);
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'edit_message',
                                chatId: editChatId,
                                messageId: editMessageId,
                                text: newText
                            }));
                        }
                    });
                    break;

                case 'delete_message':
                    if (!currentUser) break;
                    
                    const { chatId: deleteChatId, messageId: deleteMessageId, forEveryone } = data;
                    
                    if (forEveryone) {
                        db.run(`DELETE FROM messages WHERE id = ?`, [deleteMessageId]);
                    }
                    
                    clients.forEach((client, userId) => {
                        if (client && client.readyState === WebSocket.OPEN) {
                            client.send(JSON.stringify({
                                type: 'delete_message',
                                chatId: deleteChatId,
                                messageId: deleteMessageId
                            }));
                        }
                    });
                    break;

                case 'typing':
                    if (!currentUser) break;
                    
                    const { chatId: typingChatId } = data;
                    
                    const targetSocket = clients.get(typingChatId);
                    if (targetSocket && targetSocket.readyState === WebSocket.OPEN) {
                        targetSocket.send(JSON.stringify({
                            type: 'typing',
                            chatId: currentUser.userId,
                            userId: currentUser.userId
                        }));
                    }
                    break;

                case 'save_message':
                    if (!currentUser) break;
                    
                    const { messageId: saveMessageId } = data;
                    
                    db.run(`INSERT OR IGNORE INTO saved_messages (user_id, message_id) VALUES (?, ?)`,
                        [currentUser.userId, saveMessageId]);
                    break;

                case 'mark_read':
                    if (!currentUser) break;
                    
                    const { chatId: readChatId, messageId: readMessageId } = data;
                    
                    db.run(`UPDATE messages SET read = 1, read_at = CURRENT_TIMESTAMP WHERE id = ?`, [readMessageId]);
                    
                    const readTargetSocket = clients.get(readChatId);
                    if (readTargetSocket && readTargetSocket.readyState === WebSocket.OPEN) {
                        readTargetSocket.send(JSON.stringify({
                            type: 'message_read',
                            chatId: currentUser.userId,
                            messageId: readMessageId
                        }));
                    }
                    break;

                case 'create_story':
                    if (!currentUser) break;
                    
                    const { storyImage, storyText } = data;
                    
                    db.run(`INSERT INTO stories (user_id, image_url, text) VALUES (?, ?, ?)`,
                        [currentUser.userId, storyImage, storyText], function(err) {
                            if (!err) {
                                const storyId = this.lastID;
                                
                                getFriendsList(currentUser.userId, (friends) => {
                                    friends.forEach(friend => {
                                        const friendWs = clients.get(friend.id);
                                        if (friendWs && friendWs.readyState === WebSocket.OPEN) {
                                            friendWs.send(JSON.stringify({
                                                type: 'new_story',
                                                storyId: storyId,
                                                userId: currentUser.userId,
                                                userName: currentUser.username,
                                                imageUrl: storyImage,
                                                text: storyText
                                            }));
                                        } else {
                                            sendPushNotification(
                                                friend.id,
                                                currentUser.username,
                                                'ðŸ“¸ ÐžÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°Ð»(Ð°) Ð½Ð¾Ð²ÑƒÑŽ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ',
                                                { type: 'new_story', storyId: storyId.toString() }
                                            );
                                        }
                                    });
                                });
                            }
                        });
                    break;

                case 'view_story':
                    if (!currentUser) break;
                    
                    const { storyId: viewStoryId, reaction: storyReaction } = data;
                    
                    db.run(`INSERT OR IGNORE INTO story_views (story_id, user_id, reaction) VALUES (?, ?, ?)`,
                        [viewStoryId, currentUser.userId, storyReaction]);
                    break;

                case 'get_stickers':
                    db.all(`SELECT * FROM stickers`, [], (err, stickers) => {
                        ws.send(JSON.stringify({ type: 'stickers_list', stickers: stickers || [] }));
                    });
                    break;

                case 'search_messages':
                    if (!currentUser) break;
                    
                    const { searchQuery, searchFrom, searchDate } = data;
                    
                    let query = `SELECT m.*, u.name as from_name 
                                 FROM messages m
                                 JOIN users u ON u.id = m.from_id
                                 WHERE (m.from_id = ? OR m.to_id = ?)`;
                    let params = [currentUser.userId, currentUser.userId];
                    
                    if (searchQuery) {
                        query += ` AND m.text LIKE ?`;
                        params.push(`%${searchQuery}%`);
                    }
                    if (searchFrom) {
                        query += ` AND m.from_id = ?`;
                        params.push(searchFrom);
                    }
                    if (searchDate) {
                        query += ` AND date(m.timestamp) = date(?)`;
                        params.push(searchDate);
                    }
                    
                    query += ` ORDER BY m.timestamp DESC LIMIT 100`;
                    
                    db.all(query, params, (err, messages) => {
                        ws.send(JSON.stringify({ type: 'search_results', messages: messages || [] }));
                    });
                    break;

                case 'create_bot':
                    if (!currentUser || currentUser.userId !== ADMIN_ID) break;
                    
                    const { botName, botToken, webhookUrl } = data;
                    
                    const botId = 'bot_' + Date.now();
                    
                    db.run(`INSERT INTO bots (id, name, token, owner_id, webhook_url) VALUES (?, ?, ?, ?, ?)`,
                        [botId, botName, botToken, currentUser.userId, webhookUrl]);
                    break;

                case 'bot_message':
                    const { botId, chatId, botText } = data;
                    
                    db.get(`SELECT * FROM bots WHERE id = ?`, [botId], (err, bot) => {
                        if (bot && bot.webhook_url) {
                            axios.post(bot.webhook_url, {
                                message: botText,
                                from: botId,
                                to: chatId,
                                timestamp: new Date().toISOString()
                            }).catch(e => console.log('Webhook error:', e));
                        }
                    });
                    break;
            }
        } catch (e) {
            console.log('âŒ ÐžÑˆÐ¸Ð±ÐºÐ°:', e);
        }
    });

    ws.on('close', () => {
        if (currentUser) {
            clients.delete(currentUser.userId);
            
            // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ (ÐµÑÐ»Ð¸ Ð½Ðµ Ð½ÐµÐ²Ð¸Ð´Ð¸Ð¼ÐºÐ°)
            db.get(`SELECT invisible_mode FROM users WHERE id = ?`, [currentUser.userId], (err, user) => {
                if (!err && user && !user.invisible_mode) {
                    db.run(`UPDATE users SET status = 'offline', last_seen = CURRENT_TIMESTAMP WHERE id = ?`, [currentUser.userId]);
                }
            });
            
            console.log(`ðŸ‘‹ ${currentUser.username} Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ`);
        }
    });
});

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

server.listen(PORT, HOST, () => {
    console.log(`ðŸš€ Ð¡ÐµÑ€Ð²ÐµÑ€ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Ð½Ð° Ð¿Ð¾Ñ€Ñ‚Ñƒ ${PORT}`);
    console.log(`ðŸ“ Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ: https://my-messenger-xiic.onrender.com/api/register`);
    console.log(`ðŸ”‘ Ð’Ñ…Ð¾Ð´: https://my-messenger-xiic.onrender.com/api/login`);
});

















